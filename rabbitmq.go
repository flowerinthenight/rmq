package rmq

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"runtime"
	"sync/atomic"
	"time"

	"github.com/satori/go.uuid"
	"github.com/streadway/amqp"
)

type ExchangeOptions struct {
	Name       string
	Type       string
	Durable    bool
	AutoDelete bool
	Internal   bool
	NoWait     bool
	Args       amqp.Table
}

type QueueOptions struct {
	QueueName  string
	Durable    bool // will be set to false when queue name is empty (autogenerated name)
	AutoDelete bool
	Exclusive  bool
	NoWait     bool
	Args       amqp.Table
}

type QueueBindOptions struct {
	RoutingKey string
	NoWait     bool
	Args       amqp.Table
}

type ConsumeOptions struct {
	ClientTag  string
	NoAck      bool
	Exclusive  bool
	NoWait     bool
	Args       amqp.Table
	FnCallback func([]byte) error
}

type exchangeQueueBinding struct {
	tagPrefix    string // this + generated uuid as tag when queue name is generated
	tempTag      string // this as tag when queue name is provided
	exchangeOpt  *ExchangeOptions
	queueOpt     *QueueOptions
	queueBindOpt *QueueBindOptions
	consumeOpt   *ConsumeOptions
}

func (e *exchangeQueueBinding) setup(ch *amqp.Channel) error {
	// At the very least, we should have an exchange option to be able to send to an exchange.
	if e.exchangeOpt == nil {
		return fmt.Errorf("exchange option not provided")
	}

	err := ch.ExchangeDeclare(
		e.exchangeOpt.Name,       // name of the exchange
		e.exchangeOpt.Type,       // type
		e.exchangeOpt.Durable,    // durable
		e.exchangeOpt.AutoDelete, // delete when complete
		e.exchangeOpt.Internal,   // internal
		e.exchangeOpt.NoWait,     // no wait
		e.exchangeOpt.Args,       // arguments
	)

	if err != nil {
		return err
	}

	if e.queueOpt == nil {
		return nil
	}

	autoDelete := e.queueOpt.AutoDelete
	if e.queueOpt.QueueName == "" {
		autoDelete = true
	}

	queue, err := ch.QueueDeclare(
		e.queueOpt.QueueName, // name of the queue
		e.queueOpt.Durable,   // durable
		autoDelete,           // delete when unused
		e.queueOpt.Exclusive, // exclusive
		e.queueOpt.NoWait,    // no wait
		e.queueOpt.Args,      // arguments
	)

	if err != nil {
		return err
	}

	if e.queueBindOpt == nil {
		return fmt.Errorf("queue bind option not provided")
	}

	log.Printf("[info] queue (%q %d messages, %d consumers), binding to exchange (key %q)",
		queue.Name, queue.Messages, queue.Consumers, e.queueBindOpt.RoutingKey)

	err = ch.QueueBind(
		queue.Name,                // name of the queue
		e.queueBindOpt.RoutingKey, // routing key
		e.exchangeOpt.Name,        // source exchange
		e.queueBindOpt.NoWait,     // no wait
		e.queueBindOpt.Args,       // arguments
	)

	if err != nil {
		return err
	}

	if e.consumeOpt == nil {
		return nil
	}

	if e.consumeOpt.FnCallback == nil {
		return fmt.Errorf("no callback function for consume")
	}

	tag := e.tempTag
	if e.queueOpt.QueueName == "" {
		tag = e.tagPrefix + fmt.Sprintf("_%s", uuid.NewV4())
	}

	d, err := ch.Consume(
		queue.Name,             // name
		tag,                    // client tag,
		e.consumeOpt.NoAck,     // no ack
		e.consumeOpt.Exclusive, // exclusive
		false,               // noLocal (not supported in RabbitMQ)
		e.consumeOpt.NoWait, // no wait
		e.consumeOpt.Args,   // arguments
	)

	if err != nil {
		return err
	}

	go func() {
		for m := range d {
			body := m.Body[:]
			if e.consumeOpt.FnCallback != nil {
				_ = e.consumeOpt.FnCallback(body)
			}

			// manual ack
			if !e.consumeOpt.NoAck {
				m.Ack(false)
			}
		}
	}()

	return nil
}

type Config struct {
	Host        string
	Port        int
	Username    string
	Password    string
	Vhost       string
	AutoConnect bool
}

type RabbitMqBroker struct {
	config          *Config
	conn            *amqp.Connection
	channel         *amqp.Channel
	done            chan error
	lastRecoverTime int64
	currentStatus   atomic.Value
	bindings        map[string]*exchangeQueueBinding
}

func New(c *Config) *RabbitMqBroker {
	broker := &RabbitMqBroker{
		config:          c,
		done:            make(chan error),
		lastRecoverTime: time.Now().Unix(),
		bindings:        make(map[string]*exchangeQueueBinding),
	}

	broker.currentStatus.Store(false)
	return broker
}

func (b *RabbitMqBroker) Connect() error {
	if b.config == nil {
		return fmt.Errorf("config is nil")
	}

	conf := amqp.URI{
		Scheme:   "amqp",
		Host:     b.config.Host,
		Port:     b.config.Port,
		Username: b.config.Username,
		Password: b.config.Password,
		Vhost:    b.config.Vhost,
	}.String()

	var err error

	b.conn, err = amqp.Dial(conf)
	if err != nil {
		return err
	}

	if b.config.AutoConnect {
		go func() {
			v, ok := <-b.conn.NotifyClose(make(chan *amqp.Error))
			if v == nil && !ok {
				runtime.Goexit()
			}

			log.Println("[error] NotifyClose error:", v)
			retry := 1

			for {
				b.Close()
				time.Sleep(time.Duration(15+rand.Intn(60)+2*retry) * time.Second)
				log.Println("[info] try reconnect:", retry)

				// try to reconnect
				if err := b.Connect(); err != nil {
					log.Println("[error] retry:", retry, err)
					retry += 1
				} else {
					log.Println("[info] reconnect successful")
					break
				}
			}
		}()
	}

	b.channel, err = b.conn.Channel()
	if err != nil {
		return err
	}

	log.Println("[info] connection established")
	b.currentStatus.Store(true)

	// re-establish exchange-queue bindings
	if len(b.bindings) > 0 {
		for k, v := range b.bindings {
			log.Println("[info] resetup binding:", k, v)
			err = v.setup(b.channel)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

type BindConfig struct {
	ExchangeOpt  *ExchangeOptions
	QueueOpt     *QueueOptions
	QueueBindOpt *QueueBindOptions
	ConsumeOpt   *ConsumeOptions
}

func (b *RabbitMqBroker) AddBinding(bc *BindConfig) (string, error) {
	name, err := os.Hostname()
	if err != nil {
		name = "sim"
	}

	id := fmt.Sprintf("%s", uuid.NewV4())

	var tagPrefix, tempTag string

	if bc.ConsumeOpt != nil {
		tagPrefix = fmt.Sprintf("%s_%s", bc.ConsumeOpt.ClientTag, name)
		tempTag = fmt.Sprintf("%s_%s", tagPrefix, id)
	}

	b.bindings[id] = &exchangeQueueBinding{
		exchangeOpt:  bc.ExchangeOpt,
		queueOpt:     bc.QueueOpt,
		queueBindOpt: bc.QueueBindOpt,
		consumeOpt:   bc.ConsumeOpt,
		tagPrefix:    tagPrefix,
		tempTag:      tempTag,
	}

	v, _ := b.bindings[id]
	err = v.setup(b.channel)
	if err != nil {
		return "", err
	}

	return id, nil
}

func (b *RabbitMqBroker) Send(id, key string, payload []byte) error {
	bind, ok := b.bindings[id]
	if !ok {
		return fmt.Errorf("binding not found")
	}

	return b.channel.Publish(bind.exchangeOpt.Name,
		key,
		false,
		false,
		amqp.Publishing{
			ContentType: "text/plain",
			Body:        payload,
		},
	)
}

type SendConfig struct {
	Mandatory   bool
	Immediate   bool
	PublishConf *amqp.Publishing
}

func (b *RabbitMqBroker) SendWithConfig(id, key string, sc SendConfig) error {
	bind, ok := b.bindings[id]
	if !ok {
		return fmt.Errorf("binding not found")
	}

	if sc.PublishConf == nil {
		return fmt.Errorf("publish config should not be nil")
	}

	return b.channel.Publish(bind.exchangeOpt.Name, key, sc.Mandatory, sc.Immediate, *sc.PublishConf)
}

func (b *RabbitMqBroker) Close() {
	if b.channel != nil {
		b.channel.Close()
		b.channel = nil
	}

	if b.conn != nil {
		b.conn.Close()
		b.conn = nil
	}
}
