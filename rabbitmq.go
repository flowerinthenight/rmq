package rmq

import (
	"fmt"
	"math/rand"
	"os"
	"runtime"
	"sync/atomic"
	"time"

	"github.com/satori/go.uuid"
	"github.com/streadway/amqp"
)

const RECOVER_INTERVAL_TIME = 6 * 60

// Simple interface for internal logging.
type Logger interface {
	Println(v ...interface{})
}

type ExchangeOptions struct {
	Name       string
	Type       string
	Durable    bool
	AutoDelete bool
	Internal   bool
	NoWait     bool
	Args       amqp.Table
}

type QueueOptions struct {
	QueueName  string
	Durable    bool // will be set to false when queue name is empty (autogenerated name)
	AutoDelete bool
	Exclusive  bool
	NoWait     bool
	Args       amqp.Table
}

type QueueBindOptions struct {
	RoutingKey string
	NoWait     bool
	Args       amqp.Table
}

type ConsumeOptions struct {
	ClientTag  string
	NoAck      bool
	Exclusive  bool
	NoWait     bool
	Args       amqp.Table
	FnCallback func([]byte) error
}

type exchangeQueueBinding struct {
	logger       Logger // should point to parent logger
	tagPrefix    string // this + generated uuid as tag when queue name is generated
	tempTag      string // this as tag when queue name is provided
	exchangeOpt  *ExchangeOptions
	queueOpt     *QueueOptions
	queueBindOpt *QueueBindOptions
	consumeOpt   *ConsumeOptions
}

// Setup exchange/queue bindings based on provided configs.
func (e *exchangeQueueBinding) setup(ch *amqp.Channel) error {
	// At the very least, we should have an exchange option to be able to send to an exchange.
	if e.exchangeOpt == nil {
		return fmt.Errorf("exchange option not provided")
	}

	e.logger.Println("[info] setup exchange:", e.exchangeOpt.Name, e.exchangeOpt.Type)
	err := ch.ExchangeDeclare(
		e.exchangeOpt.Name,       // name of the exchange
		e.exchangeOpt.Type,       // type
		e.exchangeOpt.Durable,    // durable
		e.exchangeOpt.AutoDelete, // delete when complete
		e.exchangeOpt.Internal,   // internal
		e.exchangeOpt.NoWait,     // no wait
		e.exchangeOpt.Args,       // arguments
	)

	if err != nil {
		e.logger.Println("[error]", err)
		return err
	}

	if e.queueOpt == nil {
		return nil
	}

	autoDelete := e.queueOpt.AutoDelete
	if e.queueOpt.QueueName == "" {
		autoDelete = true
	}

	e.logger.Println("[info] setup queue:", e.queueOpt.QueueName)
	queue, err := ch.QueueDeclare(
		e.queueOpt.QueueName, // name of the queue
		e.queueOpt.Durable,   // durable
		autoDelete,           // delete when unused
		e.queueOpt.Exclusive, // exclusive
		e.queueOpt.NoWait,    // no wait
		e.queueOpt.Args,      // arguments
	)

	if err != nil {
		e.logger.Println("[error]", err)
		return err
	}

	if e.queueBindOpt == nil {
		return fmt.Errorf("queue bind option not provided")
	}

	e.logger.Println(fmt.Sprintf("[info] queue (%q %d messages, %d consumers), binding to exchange (key %q)",
		queue.Name, queue.Messages, queue.Consumers, e.queueBindOpt.RoutingKey))

	err = ch.QueueBind(
		queue.Name,                // name of the queue
		e.queueBindOpt.RoutingKey, // routing key
		e.exchangeOpt.Name,        // source exchange
		e.queueBindOpt.NoWait,     // no wait
		e.queueBindOpt.Args,       // arguments
	)

	if err != nil {
		e.logger.Println("[error]", err)
		return err
	}

	if e.consumeOpt == nil {
		return nil
	}

	if e.consumeOpt.FnCallback == nil {
		return fmt.Errorf("no callback function for consume")
	}

	tag := e.tempTag
	if e.queueOpt.QueueName == "" {
		tag = e.tagPrefix + fmt.Sprintf("_%s", uuid.NewV4())
	}

	e.logger.Println("[info] start consume:", tag)
	d, err := ch.Consume(
		queue.Name,             // name
		tag,                    // client tag,
		e.consumeOpt.NoAck,     // no ack
		e.consumeOpt.Exclusive, // exclusive
		false,               // noLocal (not supported in RabbitMQ)
		e.consumeOpt.NoWait, // no wait
		e.consumeOpt.Args,   // arguments
	)

	if err != nil {
		e.logger.Println("[error]", err)
		return err
	}

	go func() {
		e.logger.Println("[info] start receive...")
		for m := range d {
			body := m.Body[:]
			if e.consumeOpt.FnCallback != nil {
				_ = e.consumeOpt.FnCallback(body)
			}

			// manual ack
			if !e.consumeOpt.NoAck {
				m.Ack(false)
			}
		}
	}()

	return nil
}

type Config struct {
	Host     string
	Port     int
	Username string
	Password string
	Vhost    string
}

// Reconnect logic reference: https://gist.github.com/simpleton/9a2d4fde5c73af8f3f453df9747a86e5
type RabbitMqBroker struct {
	logger          Logger
	config          *Config
	conn            *amqp.Connection
	channel         *amqp.Channel
	done            chan error
	lastRecoverTime int64
	currentStatus   atomic.Value
	bindings        map[string]*exchangeQueueBinding
}

func New(c *Config, logger Logger) *RabbitMqBroker {
	broker := &RabbitMqBroker{
		logger:          logger,
		config:          c,
		done:            make(chan error),
		lastRecoverTime: time.Now().Unix(),
		bindings:        make(map[string]*exchangeQueueBinding),
	}

	broker.currentStatus.Store(false)
	return broker
}

func (b *RabbitMqBroker) Connect() error {
	if b.config == nil {
		return fmt.Errorf("config is nil")
	}

	conf := amqp.URI{
		Scheme:   "amqp",
		Host:     b.config.Host,
		Port:     b.config.Port,
		Username: b.config.Username,
		Password: b.config.Password,
		Vhost:    b.config.Vhost,
	}.String()

	var err error
	b.conn, err = amqp.Dial(conf)
	if err != nil {
		b.logger.Println("[error]", err)
		return err
	}

	go func() {
		v, ok := <-b.conn.NotifyClose(make(chan *amqp.Error))
		if v == nil && !ok {
			runtime.Goexit()
		}

		b.logger.Println("[error] NotifyClose error:", v)
		retry := 1

		for {
			b.Close()
			time.Sleep(time.Duration(15+rand.Intn(60)+2*retry) * time.Second)
			b.logger.Println("[info] try reconnect:", retry)

			// try to reconnect
			if err := b.Connect(); err != nil {
				b.logger.Println("[error] retry:", retry, err)
				retry += 1
			} else {
				b.logger.Println("[info] reconnect successful")
				break
			}
		}
	}()

	b.channel, err = b.conn.Channel()
	if err != nil {
		b.logger.Println("[error]", err)
		return err
	}

	b.logger.Println("[info] connection established")
	b.currentStatus.Store(true)

	// re-establish exchange-queue bindings
	if len(b.bindings) > 0 {
		for k, v := range b.bindings {
			b.logger.Println("[info] resetup binding:", k, v)
			err = v.setup(b.channel)
			if err != nil {
				b.logger.Println(nil)
			}
		}
	}

	return nil
}

// When 'consumeOpt' is not nil, this binding will be set to consume messages.
func (b *RabbitMqBroker) AddBinding(exchangeOpt *ExchangeOptions, queueOpt *QueueOptions, queueBindOpt *QueueBindOptions, consumeOpt *ConsumeOptions) (string, error) {
	name, err := os.Hostname()
	if err != nil {
		name = "sim"
	}

	id := fmt.Sprintf("%s", uuid.NewV4())

	var tagPrefix, tempTag string
	if consumeOpt != nil {
		tagPrefix = fmt.Sprintf("%s_%s", consumeOpt.ClientTag, name)
		tempTag = fmt.Sprintf("%s_%s", tagPrefix, id)
	}

	b.bindings[id] = &exchangeQueueBinding{
		logger:       b.logger,
		exchangeOpt:  exchangeOpt,
		queueOpt:     queueOpt,
		queueBindOpt: queueBindOpt,
		consumeOpt:   consumeOpt,
		tagPrefix:    tagPrefix,
		tempTag:      tempTag,
	}

	v, _ := b.bindings[id]
	err = v.setup(b.channel)
	if err != nil {
		b.logger.Println("[error]", err)
		return "", err
	}

	return id, nil
}

func (b *RabbitMqBroker) Send(id, key string, mandatory, immediate bool, payload []byte) error {
	bind, ok := b.bindings[id]
	if !ok {
		return fmt.Errorf("binding not found")
	}

	return b.channel.Publish(bind.exchangeOpt.Name, key, mandatory, immediate, amqp.Publishing{
		ContentType: "text/plain",
		Body:        payload,
	})
}

func (b *RabbitMqBroker) Close() {
	if b.channel != nil {
		b.channel.Close()
		b.channel = nil
	}

	if b.conn != nil {
		b.conn.Close()
		b.conn = nil
	}
}
